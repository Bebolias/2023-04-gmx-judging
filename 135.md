Ch_301

false

# [H] [05-20 08:57] Users could pay 0 fees for their trade

## Summary
the `IncreasePositionUtils.processCollateral()` and `DecreasePositionUtils.processCollateral()` always assume that the Collateral token is the same as the long/short position token. 

## Vulnerability Detail
`processCollateral()` passes the Collateral token price to `getPositionFees()` without checking if the collateral token and position token are different or not.

This function [getPositionFeesAfterReferral()](https://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/pricing/PositionPricingUtils.sol#L526-L548) is to get position fees after applying referral rebates/discounts

```solidity
 fees.positionFeeAmount = Precision.applyFactor(sizeDeltaUsd, fees.positionFeeFactor) / collateralTokenPrice.min;
```
and in this line, it computes `positionFeeAmount` like this: `sizeDeltaUsd / collateralTokenPrice`

e.g. in the market of (USDC/WETH). 
  The user will open a long position (so the `sizeDeltaUsd` is for WETH) 
  but he set `USDC` as collateral (so `collateralTokenPric` is the price of USDC ) 

in that calculation, it will be like this (X amount of WETH in USD value / the price of USDC) and this is wrong.

Users could pay 0 fees for their trade and this depends on the LongToken and ShortToken because of this line's `fees.protocolFeeAmount = fees.positionFeeAmount - fees.referral.totalRebateAmount;` could revert 

## Impact
The impact depends on the LongToken and ShortToken:
- Users have the option to trade without incurring any fees
- No one will be able to execute order Increase/Decrease with different collateral token 

## Code Snippet

## Tool used

Manual Review

## Recommendation
`processCollateral()` should pss both prices and check the `isLong` to pass the right price to this calculation
```solidity
 fees.positionFeeAmount = Precision.applyFactor(sizeDeltaUsd, fees.positionFeeFactor) / collateralTokenPrice.min;
```